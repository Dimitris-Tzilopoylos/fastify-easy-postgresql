const Column = require("./column");
const {
  WHERE_CLAUSE_OPERATORS,
  QUERY_BINDER_KEYS,
  REQUIRE_CAST_TO_NULL,
  REQUIRE_WILDCARD_TRANSFORMATION,
  IS_POSTGRES,
  SupportedAggregations,
  START_TRANSACTION,
  COMMIT,
  ROLLBACK,
  SELF_UPDATE_OPERATORS,
  EVENTS,
  REQUIRE_ARRAY_TRANSFORMATION,
} = require("./constants");
const { Pool, types, Client } = require("pg");
const { EventEmitter } = require("events");
const Scheduler = require("./scheduler");
types.setTypeParser(types.builtins.INT8, (x) => {
  return x && DB.isString(x) && x.length > 16 ? x : parseInt(x);
});
class DB {
  static models = {};
  static modelFactory = {};
  static database = {};
  static enableLog = false;
  static scheduler = Scheduler;
  static allowedOrderDirectionsKeys = {
    ASC: "ASC",
    DESC: "DESC",
    asc: "ASC",
    desc: "DESC",
    ...(IS_POSTGRES && {
      asc_nulls_first: "ASC NULLS FIRST",
      asc_nulls_last: "ASC NULLS LAST",
      desc_nulls_first: "DESC NULLS FIRST",
      desc_nulls_last: "DESC NULLS LAST",
    }),
  };
  static connectionConfig = {
    host: process.env.DB_HOST,
    port: process.env.DB_PORT,
    user: process.env.DB_USER,
    password: process.env.DB_PASSWORD,
    database: process.env.DB_NAME,
    max: 50,
    min: 0,
    idleTimeoutMillis: 0,
    connectionTimeoutMillis: 0,
    statement_timeout: 20000,
  };
  static EventNameSpaces = EVENTS;
  static pool = new Pool(DB.connectionConfig);
  static client = new Client(DB.connectionConfig);
  static clientConnected = false;
  static brokerEvents = {};
  static notificationRegistered = false;
  static events = {
    [EVENTS.SELECT]: {},
    [EVENTS.INSERT]: {},
    [EVENTS.UPDATE]: {},
    [EVENTS.DELETE]: {},
    [EVENTS.ERROR]: {},
  };
  static asyncEvents = {
    [EVENTS.SELECT]: {},
    [EVENTS.INSERT]: {},
    [EVENTS.UPDATE]: {},
    [EVENTS.DELETE]: {},
    [EVENTS.ERROR]: {},
  };
  static emitter = new EventEmitter();
  constructor(connection = null) {
    this.connection = connection;
    this.connected = !!connection;
    this.transaction = false;
    this.database = DB.database;
    this.driver = null;
  }
  static async connectClient() {
    if (!DB.clientConnected) {
      try {
        DB.clientConnected = true;
        await DB.client.connect();
      } catch (error) {
        DB.clientConnected = false;
      }
    }
  }
  static async clientDisconnect() {
    if (DB.clientConnected) {
      await DB.client.end();
      DB.clientConnected = false;
    }
  }
  async connect() {
    if (this.connected) {
      return;
    }
    this.connection = await DB.pool.connect();
    this.connected = true;
  }
  disconnect() {
    if (!this.connected) {
      return;
    }
    if (this.transaction) {
      this.rollback()
        .then((x) => {
          this.connection.release();
          this.connected = false;
          this.transaction = false;
        })
        .catch((err) => {
          this.connection.release();
          this.connected = false;
          this.transaction = false;
        });
    } else {
      this.connection.release();
      this.connected = false;
      this.transaction = false;
    }
  }
  async startTransaction() {
    await this.connection.query(START_TRANSACTION);
    this.transaction = true;
  }
  async commit() {
    if (!this.transaction) {
      return;
    }
    await this.connection.query(COMMIT);
    this.transaction = false;
  }
  async rollback() {
    if (!this.transaction) {
      return;
    }
    await this.connection.query(ROLLBACK);
    this.transaction = false;
  }
  async withTransaction(cb) {
    try {
      await this.connect();
      await this.startTransaction();
      const result = await cb(this.connection);
      await this.commit();
      this.disconnect();
      return result;
    } catch (error) {
      await this.rollback();
      this.disconnect();
      return error;
    }
  }
  async selectQueryExec(sql, args = []) {
    const {
      rows: [result],
    } = this.connection
      ? await this.connection.query(sql, args)
      : await DB.pool.query(sql, args);
    return result;
  }
  async insertQueryExec(sql, args) {
    const { rows } = this.connection
      ? await this.connection.query(sql, args)
      : await DB.pool.query(sql, args);
    return rows;
  }
  async updateQueryExec(sql, args) {
    const { rows } = this.connection
      ? await this.connection.query(sql, args)
      : await DB.pool.query(sql, args);
    return rows;
  }
  async deleteQueryExec(sql, args) {
    const { rows } = this.connection
      ? await this.connection.query(sql, args)
      : await DB.pool.query(sql, args);
    return rows;
  }
  async raw(sql, args = []) {
    return await DB.pool.query(sql, args);
  }
  async findOne({
    where = {},
    include = {},
    aggregate = null,
    orderBy,
    groupBy,
    distinct,
  } = {}) {
    try {
      const [result] = await this.find({
        where,
        include,
        aggregate,
        orderBy,
        groupBy,
        distinct,
        limit: 1,
      });
      return result;
    } catch (error) {
      throw error;
    }
  }
  async find({
    where = {},
    include = {},
    aggregate = null,
    orderBy,
    groupBy,
    distinct,
    limit,
    offset,
  } = {}) {
    try {
      let depth = 0;
      let index = 1;
      const alias = this.makeDepthAlias(this.table, depth);
      const args = [];
      const modelColumnsStr = this.getModelColumnsCommaSeperatedString(alias);
      const selectColumnsStr = [modelColumnsStr]
        .concat(
          Object.keys(include).map(
            (alias, idx) => `${this.makeDepthAlias(alias, 1 + idx)}.${alias}`
          )
        )
        .join(",");
      let sql = `SELECT coalesce(json_agg(${alias}),'[]') as ${this.table} 
        FROM (
          SELECT row_to_json((
            SELECT ${alias}
            FROM ( SELECT ${selectColumnsStr}) ${alias} )) ${alias}
            FROM (
              SELECT ${this.makeDistinctOn(
                distinct,
                alias
              )} ${modelColumnsStr} FROM ${DB.database}.${this.table} ${alias}`;
      const self = this;
      function makeQuery(model, relations, depth, prevAlias) {
        if (!relations || typeof relations === "boolean") {
          return "";
        }
        let sql = ``;
        const _iter = Object.entries(relations);
        for (let i = 0; i < _iter.length; i++) {
          const [_alias, config] = _iter[i];
          const alias = DB.getRelationNameWithoutAggregate(_alias);
          const isAggregate = DB.getIsAggregate(_alias);
          const relation = model.relations[alias];
          if (!relation) {
            throw new Error("no such relation");
          }
          const currentModel = DB.getRelatedModel(relation.to_table);
          if (!currentModel) {
            throw new Error(`no such model for table ${relation.to_table}`);
          }
          const depthAlias = isAggregate
            ? self.makeDepthAlias(relation.alias, depth + i) + "_aggregate"
            : self.makeDepthAlias(relation.alias, depth + i);
          const coalesceFallback = relation.type === "object" ? "null" : "[]";
          const coalesceAppendex = relation.type === "object" ? "->0" : "";
          const modelColumnsStr =
            currentModel.getModelColumnsCommaSeperatedString(depthAlias);
          const { distinct, groupBy, orderBy, where, include, limit, offset } =
            DB.isObject(config) ? config : {};
          const selectColumnsStr = [modelColumnsStr]
            .concat(
              Object.keys(include || {}).map(
                (alias, idx) =>
                  `${self.makeDepthAlias(alias, depth + 1 + idx)}.${alias}`
              )
            )
            .join(",");
          if (isAggregate) {
            const [agg] = currentModel.aggregateInternal({
              ...config,
              alias: depthAlias,
            });
            sql += `
              LEFT JOIN LATERAL  (${agg} 
            `;
          } else {
            sql += ` 
          LEFT OUTER JOIN LATERAL ( SELECT coalesce(json_agg(${depthAlias})${coalesceAppendex},'${coalesceFallback}') as ${
              relation.alias
            } 
          FROM (
            SELECT row_to_json((
              SELECT ${depthAlias}
              FROM ( SELECT ${selectColumnsStr}) ${depthAlias} )) ${depthAlias}
              FROM (
                SELECT ${currentModel.makeDistinctOn(
                  distinct,
                  depthAlias
                )} ${modelColumnsStr} FROM ${DB.database}.${
              currentModel.table
            } ${depthAlias} `;
          }
          const appendSql = makeQuery(
            currentModel,
            include,
            depth + 1,
            depthAlias
          );
          const [whereClauseStr, qArgs, idx] = currentModel.makeWhereClause(
            currentModel,
            where,
            index,
            depthAlias,
            false,
            false
          );
          args.push(...qArgs);
          index = idx;
          const groupByStr = currentModel.makeGroupBy(groupBy, depthAlias);
          const orderByStr = currentModel.makeOrderBy(orderBy, depthAlias);
          const [limitStr, limitArgs, idxLimit] = currentModel.makeLimit(
            limit,
            index
          );
          index = idxLimit;
          args.push(...limitArgs);
          const [offsetStr, offsetArgs, idxOffset] = currentModel.makeOffset(
            offset,
            index
          );
          args.push(...offsetArgs);
          index = idxOffset;
          if (!isAggregate) {
            sql += `
            WHERE ${prevAlias}.${relation.from_column} = ${depthAlias}.${relation.to_column}
            ${whereClauseStr}
            ${groupByStr}
            ${orderByStr}
            ${limitStr}
            ${offsetStr} ) ${depthAlias}  ${appendSql} ) ${depthAlias} ) AS ${depthAlias} ON true
            `;
          } else {
            sql += ` WHERE ${prevAlias}.${relation.from_column} = ${depthAlias}.${relation.to_column}
            ${whereClauseStr}
            ${groupByStr} )   AS ${depthAlias} ON true`;
          }
        }
        return sql;
      }
      const [whereClauseStr, whereArgs, idx] = this.makeWhereClause(
        this,
        where,
        index,
        alias,
        true,
        true
      );
      index = idx;
      args.push(...whereArgs);
      const groupByStr = this.makeGroupBy(groupBy, alias);
      const orderByStr = this.makeOrderBy(orderBy, alias);
      const [limitStr, limitArgs, idxLimit] = this.makeLimit(limit, index);
      index = idxLimit;
      args.push(...limitArgs);
      const [offsetStr, offsetArgs, idxOffset] = this.makeOffset(offset, index);
      args.push(...offsetArgs);
      index = idxOffset;
      sql += `
      ${whereClauseStr}
      ${groupByStr}
      ${orderByStr}
      ${limitStr}
      ${offsetStr} ) ${alias}
      `;
      sql += makeQuery(this, include, depth + 1, alias);
      sql += ` ) ${alias}`;
      if (DB.enableLog) {
        console.log(sql);
      }
      const result = (await this.selectQueryExec(sql, args))?.[this.table];
      if (DB.eventExists(this.table, DB.EventNameSpaces.SELECT)) {
        DB.executeEvent(this.table, DB.EventNameSpaces.SELECT, result, this);
      }
      if (DB.asyncEventExists(this.table, DB.EventNameSpaces.SELECT)) {
        await DB.executeAsyncEvent(
          this.table,
          DB.EventNameSpaces.SELECT,
          result,
          this
        );
      }
      return result;
    } catch (error) {
      if (DB.eventExists(this.table, DB.EventNameSpaces.ERROR)) {
        DB.executeEvent(this.table, DB.EventNameSpaces.ERROR, error, this);
      }
      if (DB.asyncEventExists(this.table, DB.EventNameSpaces.ERROR)) {
        await DB.executeAsyncEvent(
          this.table,
          DB.EventNameSpaces.ERROR,
          error,
          this
        );
      }
      throw error;
    }
  }
  async insert(args) {
    if (!DB.isObject(args)) {
      return null;
    }
    try {
      const { onConflict, ...rest } = args;
      const [modelPayload, relationalPayload] =
        this.splitRelationalAndModelColumnsInput(rest);
      const [query, qArgs] = this.buildInsertQuery(modelPayload, onConflict);
      const [result] = await this.insertQueryExec(query, qArgs);
      const self = this;
      async function insertChildren(model, prevResult, relationalPayload) {
        const _iter = Object.keys(relationalPayload || {});
        const aggResult = {};
        if (!_iter.length) {
          return aggResult;
        }
        for (let i = 0; i < _iter.length; i++) {
          const relationAlias = _iter[i];
          const insertInput = relationalPayload[relationAlias];
          const relation = model.relations?.[relationAlias];
          if (!relation) {
            throw new Error("no such relation");
          }
          const insertionModel = DB.getRelatedModel(relation.to_table);
          if (!insertionModel) {
            throw new Error("no such model");
          }
          if (relation.type === "object" && Array.isArray(insertInput)) {
            throw new Error(
              "relation type object cannot accept an array as input"
            );
          }
          if (relation.type === "array" && !Array.isArray(insertInput)) {
            throw new Error("relation type array can only accept array inputs");
          }
          const dependedColumnValue = prevResult[relation.from_column];
          const valuesIter =
            relation.type === "object" ? [insertInput] : insertInput;
          const appendResult = [];
          for (let value of valuesIter) {
            value[relation.to_column] = dependedColumnValue;
            const { onConflict, ...rest } = value;
            const [modelPayload, relationalPayload] =
              insertionModel.splitRelationalAndModelColumnsInput(rest);
            const [query, args] = insertionModel.buildInsertQuery(
              modelPayload,
              onConflict
            );
            const [result] = await self.insertQueryExec(query, args);
            const childrenResult = await insertChildren(
              insertionModel,
              result,
              relationalPayload
            );
            if (Object.keys(childrenResult)?.length) {
              Object.assign(result, childrenResult);
            }
            appendResult.push(result);
          }
          if (relation.type === "object") {
            aggResult[relationAlias] = appendResult[0];
          } else {
            aggResult[relationAlias] = appendResult;
          }
        }
        return aggResult;
      }
      const childrenResult = await insertChildren(
        this,
        result,
        relationalPayload
      );
      if (Object.keys(childrenResult)?.length) {
        Object.assign(result, childrenResult);
      }
      return result;
    } catch (error) {
      throw error;
    }
  }
  async createTX(args) {
    try {
      await this.connect();
      const result = await this.withTransaction(async (tx) => {
        return await this.insert(args);
      });
      this.disconnect();
      if (DB.eventExists(this.table, DB.EventNameSpaces.INSERT)) {
        DB.executeEvent(this.table, DB.EventNameSpaces.INSERT, result, this);
      }
      if (DB.asyncEventExists(this.table, DB.EventNameSpaces.INSERT)) {
        await DB.executeAsyncEvent(
          this.table,
          DB.EventNameSpaces.INSERT,
          result,
          this
        );
      }
      return result;
    } catch (error) {
      this.disconnect();
      if (DB.eventExists(this.table, DB.EventNameSpaces.ERROR)) {
        DB.executeEvent(this.table, DB.EventNameSpaces.ERROR, error, this);
      }
      if (DB.eventExists(this.table, DB.EventNameSpaces.ERROR)) {
        await DB.executeAsyncEvent(
          this.table,
          DB.EventNameSpaces.ERROR,
          error,
          this
        );
      }
      throw error;
    }
  }
  async createManyTX(args) {
    try {
      if (!Array.isArray(args)) {
        throw new Error("provided input is not an array");
      }
      await this.connect();
      const result = await this.withTransaction(async (tx) => {
        const promises = args.map((input) => this.insert(input));
        return await Promise.all(promises);
      });
      this.disconnect();
      if (DB.eventExists(this.table, DB.EventNameSpaces.INSERT)) {
        DB.executeEvent(this.table, DB.EventNameSpaces.INSERT, result, this);
      }
      if (DB.asyncEventExists(this.table, DB.EventNameSpaces.INSERT)) {
        await DB.executeAsyncEvent(
          this.table,
          DB.EventNameSpaces.INSERT,
          result,
          this
        );
      }
      return result;
    } catch (error) {
      this.disconnect();
      if (DB.eventExists(this.table, DB.EventNameSpaces.ERROR)) {
        DB.executeEvent(this.table, DB.EventNameSpaces.ERROR, error, this);
      }
      if (DB.asyncEventExists(this.table, DB.EventNameSpaces.ERROR)) {
        await DB.executeAsyncEvent(
          this.table,
          DB.EventNameSpaces.ERROR,
          error,
          this
        );
      }
      throw error;
    }
  }
  async create(args) {
    try {
      const result = await this.insert(args);
      if (DB.eventExists(this.table, DB.EventNameSpaces.INSERT)) {
        DB.executeEvent(this.table, DB.EventNameSpaces.INSERT, result, this);
      }
      if (DB.asyncEventExists(this.table, DB.EventNameSpaces.INSERT)) {
        await DB.executeAsyncEvent(
          this.table,
          DB.EventNameSpaces.INSERT,
          result,
          this
        );
      }
      return result;
    } catch (error) {
      if (DB.eventExists(this.table, DB.EventNameSpaces.ERROR)) {
        DB.executeEvent(this.table, DB.EventNameSpaces.ERROR, error, this);
      }
      if (DB.asyncEventExists(this.table, DB.EventNameSpaces.ERROR)) {
        await DB.executeAsyncEvent(
          this.table,
          DB.EventNameSpaces.ERROR,
          error,
          this
        );
      }
      throw error;
    }
  }
  async createMany(args) {
    try {
      if (!Array.isArray(args)) {
        throw new Error("provided input is not an array");
      }
      const promises = args.map((input) => this.insert(input));
      const result = await Promise.all(promises);
      if (DB.eventExists(this.table, DB.EventNameSpaces.INSERT)) {
        DB.executeEvent(this.table, DB.EventNameSpaces.INSERT, result, this);
      }
      if (DB.asyncEventExists(this.table, DB.EventNameSpaces.INSERT)) {
        await DB.executeAsyncEvent(
          this.table,
          DB.EventNameSpaces.INSERT,
          result,
          this
        );
      }
      return result;
    } catch (error) {
      if (DB.eventExists(this.table, DB.EventNameSpaces.ERROR)) {
        DB.executeEvent(this.table, DB.EventNameSpaces.ERROR, error, this);
      }
      if (DB.asyncEventExists(this.table, DB.EventNameSpaces.ERROR)) {
        await DB.executeAsyncEvent(
          this.table,
          DB.EventNameSpaces.ERROR,
          error,
          this
        );
      }
      throw error;
    }
  }
  async update({ update, where = {} }) {
    try {
      const [modelColumns] = this.splitRelationalAndModelColumnsInput(
        update,
        Object.keys(SELF_UPDATE_OPERATORS)
      );
      const [columns, qArgs] = Object.entries(modelColumns).reduce(
        (acc, [key, value], idx) => {
          if (SELF_UPDATE_OPERATORS[key]) {
            if (!DB.isObject(value)) {
              throw new Error(
                "self update operators should have an object value"
              );
            }
            const [selfUpdateColumns] =
              this.splitRelationalAndModelColumnsInput(value);
            acc[0].push(
              ...Object.entries(selfUpdateColumns).map(
                ([c, val], innerIndex) => {
                  const sql = `${c} = ${c} ${SELF_UPDATE_OPERATORS[key]} $${
                    acc[1].length + 1
                  }`;
                  acc[1].push(val);
                  return sql;
                }
              )
            );
          } else {
            acc[0].push(`${key} = $${acc[1].length + 1}`);
            acc[1].push(value);
          }
          return acc;
        },
        [[], []]
      );
      const [whereStr, whereArgs] = this.makeWhereClause(
        this,
        where,
        qArgs.length + 1,
        this.table,
        true,
        true
      );
      const sql = `UPDATE ${DB.database}.${this.table} SET ${columns.join(
        ","
      )} ${whereStr} RETURNING *`;
      qArgs.push(...whereArgs);
      const result = await this.updateQueryExec(sql, qArgs);
      if (DB.eventExists(this.table, DB.EventNameSpaces.UPDATE)) {
        DB.executeEvent(this.table, DB.EventNameSpaces.UPDATE, result, this);
      }
      if (DB.asyncEventExists(this.table, DB.EventNameSpaces.UPDATE)) {
        await DB.executeAsyncEvent(
          this.table,
          DB.EventNameSpaces.UPDATE,
          result,
          this
        );
      }
      return result;
    } catch (error) {
      if (DB.eventExists(this.table, DB.EventNameSpaces.ERROR)) {
        DB.executeEvent(this.table, DB.EventNameSpaces.ERROR, error, this);
      }
      if (DB.asyncEventExists(this.table, DB.EventNameSpaces.ERROR)) {
        await DB.executeAsyncEvent(
          this.table,
          DB.EventNameSpaces.ERROR,
          error,
          this
        );
      }
      throw error;
    }
  }
  async delete({ where = {} }) {
    try {
      const [whereStr, whereArgs] = this.makeWhereClause(
        this,
        where,
        1,
        this.table,
        true,
        true
      );
      const sql = `DELETE FROM ${DB.database}.${this.table} ${whereStr} RETURNING *`;
      const result = await this.deleteQueryExec(sql, whereArgs);
      if (DB.eventExists(this.table, DB.EventNameSpaces.DELETE)) {
        DB.executeEvent(this.table, DB.EventNameSpaces.DELETE, result, this);
      }
      if (DB.asyncEventExists(this.table, DB.EventNameSpaces.DELETE)) {
        await DB.executeAsyncEvent(
          this.table,
          DB.EventNameSpaces.DELETE,
          result,
          this
        );
      }
      return result;
    } catch (error) {
      if (DB.eventExists(this.table, DB.EventNameSpaces.ERROR)) {
        DB.executeEvent(this.table, DB.EventNameSpaces.ERROR, error, this);
      }
      if (DB.asyncEventExists(this.table, DB.EventNameSpaces.ERROR)) {
        await DB.executeAsyncEvent(
          this.table,
          DB.EventNameSpaces.ERROR,
          error,
          this
        );
      }
      throw error;
    }
  }
  async aggregate({
    where,
    groupBy,
    distinct,
    _count,
    _max,
    _min,
    _sum,
    _avg,
  } = {}) {
    try {
      const countAgg = this.buildCountAgg(_count);
      const aggregations = [
        { key: "_min", value: _min },
        { key: "_max", value: _max },
        { key: "_sum", value: _sum },
        { key: "_avg", value: _avg },
      ]
        .map((x) => this.buildAgg(x.value, x.key))
        .concat(countAgg)
        .filter(Boolean)
        .join(",");
      if (!aggregations.length) {
        throw new Error("no aggregations were found for this operation");
      }
      const [whereStr, whereArgs] = this.makeWhereClause(
        this,
        where,
        1,
        this.table,
        true,
        true
      );
      const groupByStr = this.makeGroupBy(groupBy, this.table);
      const distinctStr = this.makeDistinctOn(distinct, this.table);
      const sql = `SELECT ${distinctStr} json_build_object(${aggregations})  as ${this.table}_aggregate FROM ${DB.database}.${this.table}  ${whereStr} ${groupByStr}`;
      return (await this.selectQueryExec(sql, whereArgs))?.[
        `${this.table}_aggregate`
      ];
    } catch (error) {
      throw error;
    }
  }
  aggregateInternal({
    where,
    groupBy,
    distinct,
    _count,
    _max,
    _min,
    _sum,
    _avg,
    index = 1,
    alias,
    withWhere = false,
  } = {}) {
    try {
      const countAgg = this.buildCountAgg(_count);
      const aggregations = [
        { key: "_min", value: _min },
        { key: "_max", value: _max },
        { key: "_sum", value: _sum },
        { key: "_avg", value: _avg },
      ]
        .map((x) => this.buildAgg(x.value, x.key))
        .concat(countAgg)
        .filter(Boolean)
        .join(",");
      if (!aggregations.length) {
        throw new Error("no aggregations were found for this operation");
      }
      if (withWhere) {
        const [whereStr, whereArgs, idx] = this.makeWhereClause(
          this,
          where,
          index,
          alias,
          true,
          true
        );
        const groupByStr = this.makeGroupBy(groupBy, this.table);
        const distinctStr = this.makeDistinctOn(distinct, this.table);
        const sql = `SELECT ${distinctStr} json_build_object(${aggregations})  as ${this.table}_aggregate FROM ${DB.database}.${this.table} as ${alias}  ${whereStr} ${groupByStr}`;
        return [sql, whereArgs, idx];
      }
      const groupByStr = this.makeGroupBy(groupBy, this.table);
      const distinctStr = this.makeDistinctOn(distinct, this.table);
      const sql = `SELECT ${distinctStr} json_build_object(${aggregations})  as ${this.table}_aggregate FROM ${DB.database}.${this.table} as ${alias} ${groupByStr}`;
      return [sql, "", index];
    } catch (error) {
      throw error;
    }
  }
  buildCountAgg(count) {
    if (!count) {
      return;
    }
    return `'count',COUNT(*)`;
  }
  buildAgg(aggConfig, key) {
    if (!DB.isObject(aggConfig)) {
      return;
    }
    const [modelColumns] = this.splitRelationalAndModelColumnsInput(aggConfig);
    const columns = Object.keys(modelColumns).filter((x) => !!modelColumns[x]);
    if (!columns.length) {
      return [];
    }
    return `'${SupportedAggregations[
      key
    ].toLowerCase()}',json_build_object(${columns
      .map((column) => `'${column}',${SupportedAggregations[key]}(${column})`)
      .join(",")})`;
  }
  buildInsertQuery(args, onConflict) {
    if (!DB.isObject(args)) {
      throw new Error();
    }
    const [columns, placeholders, qArgs] = Object.entries(args).reduce(
      (acc, [key, value], idx) => {
        acc[0].push(key);
        acc[1].push(`$${idx + 1}`);
        acc[2].push(value);
        return acc;
      },
      [[], [], []]
    );
    return [
      `INSERT INTO ${DB.database}.${this.table} (${columns.join(
        ","
      )}) VALUES(${placeholders.join(",")}) RETURNING *`,
      qArgs,
    ];
  }
  makeDistinctOn(distinct, alias) {
    if (!Array.isArray(distinct) || !distinct?.length) {
      return "";
    }
    const strFields = distinct
      .filter((col) => !!this.columns[col])
      .map((col) => `${alias ? `${alias}.` : ""}${col.column}`)
      .join(",");
    if (!strFields.length) {
      return "";
    }
    return `DISTINCT ON (${strFields})`;
  }
  makeWhereClause(
    model,
    where,
    index,
    alias,
    isFirstEntry = true,
    startWithWhere = true,
    binder = "AND",
    depth = 0
  ) {
    if (!model || !where || !DB.isObject(where)) {
      return ["", [], index];
    }
    const args = [];
    let _iter = Object.entries(where);
    if (!_iter?.length) {
      return ["", [], index];
    }
    let sql = startWithWhere && _iter.length ? "WHERE" : "";
    function getFirstEntry(isFirstEntry, operator) {
      if (isFirstEntry) {
        return "";
      }
      return operator || WHERE_CLAUSE_OPERATORS._and;
    }
    for (let y = 0; y < _iter.length; y++) {
      const [key, config] = _iter[y];
      if (QUERY_BINDER_KEYS[key]) {
        if (!Array.isArray(config)) {
          throw new Error(
            "No Array provided for query logical binder operation"
          );
        }
        if (!config.length) {
          continue;
        }
        sql += ` ${getFirstEntry(isFirstEntry, binder)} ( `;
        for (let i = 0; i < config.length; i++) {
          const entry = config[i];
          const [str, qArgs, idx] = this.makeWhereClause(
            model,
            entry,
            index,
            alias,
            i === 0,
            false,
            WHERE_CLAUSE_OPERATORS[key]
          );
          sql += `${str}`;
          args.push(...qArgs);
          index = idx;
        }
        sql += `)`;
      } else if (WHERE_CLAUSE_OPERATORS[key]) {
        if (REQUIRE_CAST_TO_NULL[key]) {
          sql += ` ${WHERE_CLAUSE_OPERATORS[key]} NULL`;
        } else if (REQUIRE_WILDCARD_TRANSFORMATION[key]) {
          sql += ` ${WHERE_CLAUSE_OPERATORS[key]} $${index}`;
          args.push(`%${config}%`);
          index++;
        } else if (REQUIRE_ARRAY_TRANSFORMATION[key]) {
          sql += ` ${WHERE_CLAUSE_OPERATORS[key]} ($${index})`;
          args.push(config);
          index++;
        } else {
          if (config instanceof Column) {
            sql += ` ${WHERE_CLAUSE_OPERATORS[key]} ${
              config.alias ? "" : `${alias}.`
            }${config.column}`;
          } else {
            sql += ` ${WHERE_CLAUSE_OPERATORS[key]} $${index}`;
            args.push(config);
            index++;
          }
        }
      } else if (model.columns[key]) {
        const [isArrayComparison, sqlSTR, arrayKey] =
          model.isArrayComparison(config);
        if (isArrayComparison) {
          sql += ` ${getFirstEntry(
            isFirstEntry,
            binder
          )} $${index} ${sqlSTR}(${alias}.${model.columns[key].column}) `;
          index++;
          args.push(config[arrayKey]);
          continue;
        }
        sql += ` ${getFirstEntry(isFirstEntry, binder)} ${alias}.${
          model.columns[key].column
        }`;
        const [qStr, qArgs, idx] = this.makeWhereClause(
          model,
          config,
          index,
          alias,
          isFirstEntry,
          false,
          binder
        );
        sql += qStr;
        args.push(...qArgs);
        index = idx;
      } else if (model.relations[key]) {
        const currentModel = DB.getRelatedModel(
          DB.models[model.relations[key].to_table].table
        );
        const relation = model.relations[key];
        const newAlias = this.makeDepthAlias(relation.alias, depth);
        sql += ` ${getFirstEntry(isFirstEntry, binder)} ${alias}.${
          relation.from_column
        } IN (SELECT ${relation.to_column} FROM ${DB.database}.${
          currentModel.table
        } ${newAlias} WHERE ${alias}.${relation.from_column} = ${newAlias}.${
          relation.to_column
        }`;
        const [qString, qArgs, idx] = currentModel.makeWhereClause(
          currentModel,
          where[key],
          index,
          newAlias,
          false,
          false,
          binder,
          depth + 1
        );
        sql += ` ${qString} )`;
        args.push(...qArgs);
        index = idx;
      } else {
        throw new Error("UNKNOWN OPERATION");
      }
      isFirstEntry = false;
    }
    return [sql, args, index];
  }
  isArrayComparison(config) {
    const ok = !!config?._in_array || !!config?._nin_array;
    if (!ok) {
      return [ok, undefined];
    }
    const sqlSTR = !!config?._in_array
      ? WHERE_CLAUSE_OPERATORS._in_array
      : WHERE_CLAUSE_OPERATORS._nin_array;
    return [ok, sqlSTR, !!config?._in_array ? "_in_array" : "_nin_array"];
  }
  makeGroupBy(groupBy, alias) {
    if (!Array.isArray(groupBy) || !groupBy?.length) {
      return "";
    }
    const strFields = groupBy
      .filter((col) => !!this.columns[col])
      .map((col) => `${alias ? `${alias}.` : ""}${col.column}`)
      .join(",");
    if (!strFields.length) {
      return "";
    }
    return `GROUP BY (${strFields})`;
  }
  makeOrderBy(orderBy, alias = "") {
    if (!orderBy) {
      return "";
    }
    const orderByStr = Object.entries(orderBy || {})
      .reduce((acc, [key, value]) => {
        if (!this.columns[key]) {
          return acc;
        }
        acc.push(
          ` ${alias ? `${alias}.` : ""}${key}  ${
            DB.allowedOrderDirectionsKeys[value] || "ASC"
          }`
        );
        return acc;
      }, [])
      .join(",");
    return this.combineOrderBy(
      orderByStr,
      this.getAggregationForSorting(orderBy, alias)
    );
  }
  makeLimit(limit, index) {
    if (DB.isNullOrUndefinedOrEmpty(limit)) {
      return ["", [], index];
    }
    return [`LIMIT $${index}`, [limit], index + 1];
  }
  makeOffset(offset, index) {
    if (DB.isNullOrUndefinedOrEmpty(offset)) {
      return ["", [], index];
    }
    return [`OFFSET $${index}`, [offset], index + 1];
  }
  getAggregationForSorting(orderBy, currentAlias) {
    if (!DB.isObject(orderBy)) {
      return "";
    }
    const columnsForOrdering = Object.keys(orderBy).reduce((acc, key) => {
      const isAggregation = DB.getIsAggregate(key);
      if (!isAggregation) {
        return acc;
      }
      const relationalAlias = DB.getRelationNameWithoutAggregate(key);
      const relation = this.relations?.[relationalAlias];
      if (!relation) {
        return acc;
      }
      const currModel = DB.getRelatedModel(relation.to_table);
      if (!currModel) {
        return acc;
      }
      acc = acc.concat(
        currModel.produceOrderByForAggregations(
          orderBy[key],
          currentAlias,
          relation
        )
      );
      return acc;
    }, []);
    return columnsForOrdering.join(",");
  }
  combineOrderBy(orderByColumnsString, orderByAggregationsString) {
    if (!orderByAggregationsString && !orderByColumnsString) {
      return "";
    }
    return `ORDER BY ${orderByColumnsString} ${
      orderByColumnsString && orderByAggregationsString
        ? `,${orderByAggregationsString}`
        : orderByAggregationsString
    }`;
  }
  produceOrderByForAggregations(aggrConfig, prevAlias, relation) {
    const { _count, ...rest } = aggrConfig;
    let queries = [];
    const table = `${DB.database}.${this.table} `;
    const whereClause = `${prevAlias}.${relation.from_column} = ${this.table}.${relation.to_column}`;
    if (_count) {
      queries.push(
        ` (SELECT  COUNT(*) FROM ${table} WHERE ${whereClause} ) ${
          DB.allowedOrderDirectionsKeys[_count] || "ASC"
        }`
      );
    }
    Object.entries(rest).forEach(([key, value]) => {
      if (!SupportedAggregations[key]) {
        throw { message: `Invalid aggregation type ${key}`, status: 400 };
      }
      queries = queries.concat(
        this.toOrderByByAggregationConfig({
          columnsMap: this.columns,
          aggregationKey: SupportedAggregations[key],
          table,
          whereClause,
          aggrKeyConfig: value,
        })
      );
    });
    return queries;
  }
  toOrderByByAggregationConfig({
    columnsMap,
    aggregationKey,
    aggrKeyConfig,
    table,
    whereClause,
  }) {
    return Object.keys(aggrKeyConfig).map((column) => {
      if (!columnsMap[column]) {
        throw { message: `Column ${column} doesn't exist`, status: 400 };
      }
      return `(SELECT ${aggregationKey}(${column}) FROM ${table} WHERE ${whereClause}) ${
        DB.allowedOrderDirectionsKeys[aggrKeyConfig[column]] || "ASC"
      }`;
    });
  }
  makeColumnAlias(col) {
    if (col?.name?.startsWith(this.table)) {
      return col;
    }
    return `${this.table}.${col.name}`;
  }
  makeDepthAlias(alias, depth) {
    return `_${depth}_${alias}`;
  }
  splitRelationalAndModelColumnsInput(args, allowedEntries = []) {
    return Object.entries(args).reduce(
      (acc, [key, value]) => {
        if (!this.columns[key] && !this.relations[key]) {
          if (!allowedEntries.length) {
            return acc;
          }
        }
        if (this.columns[key]) {
          acc[0][key] = value;
        } else if (allowedEntries.indexOf(key) !== -1) {
          acc[0][key] = value;
        } else {
          acc[1][key] = value;
        }
        return acc;
      },
      [{}, {}]
    );
  }
  static register(model) {
    const invoked = new model();
    DB.models[invoked.table] = new model();
    DB.modelFactory[invoked.table] = model;
    const aggModel = new model();
    aggModel.isAggregate = true;
    DB.models[`${invoked.table}_aggregate`] = aggModel;
  }
  static registerDatabase(db) {
    DB.database = db;
  }
  static registerConnectionConfig(connectionConfig = {}) {
    if (DB.pool) {
      DB.pool.end();
    }
    DB.connectionConfig = {
      ...DB.connectionConfig,
      ...connectionConfig,
    };
    DB.pool = new Pool(DB.connectionConfig);
    DB.client = new Client(DB.connectionConfig);
  }
  static getRelatedModel(table) {
    return DB.models[table];
  }
  getRelatedModelByAlias(alias) {
    return this?.relations?.[alias];
  }
  static getIsAggregate(alias) {
    return alias?.endsWith("_aggregate");
  }
  static getRelationNameWithoutAggregate(alias) {
    if (!alias) {
      return "";
    }
    return alias.split("_aggregate")[0];
  }
  static isObject(value) {
    return (
      !this.isNullOrUndefined(value) &&
      !Array.isArray(value) &&
      typeof value === "object"
    );
  }
  static isUndefined(value) {
    return typeof value === "undefined";
  }
  static isNull(value) {
    return (
      value === null ||
      (this.isString(value) && value?.toLowerCase()?.trim() === "null")
    );
  }
  static isString(value) {
    return typeof value === "string";
  }
  static isNullOrUndefined(value) {
    return this.isNull(value) || this.isUndefined(value);
  }
  static isNullOrUndefinedOrEmpty(value) {
    return this.isNull(value) || this.isUndefined(value) || value === "";
  }
  static onSelect(table, cb) {
    DB.events[DB.EventNameSpaces.SELECT][table] = cb;
  }
  static onInsert(table, cb) {
    DB.events[DB.EventNameSpaces.INSERT][table] = cb;
  }
  static onUpdate(table, cb) {
    DB.events[DB.EventNameSpaces.UPDATE][table] = cb;
  }
  static onDelete(table, cb) {
    DB.events[DB.EventNameSpaces.DELETE][table] = cb;
  }
  static onError(table, cb) {
    DB.events[DB.EventNameSpaces.ERROR][table] = cb;
  }
  static onSelectAsync(table, cb) {
    DB.asyncEvents[DB.EventNameSpaces.SELECT][table] = cb;
  }
  static onInsertAsync(table, cb) {
    DB.asyncEvents[DB.EventNameSpaces.INSERT][table] = cb;
  }
  static onUpdateAsync(table, cb) {
    DB.asyncEvents[DB.EventNameSpaces.UPDATE][table] = cb;
  }
  static onDeleteAsync(table, cb) {
    DB.asyncEvents[DB.EventNameSpaces.DELETE][table] = cb;
  }
  static onErrorAsync(table, cb) {
    DB.asyncEvents[DB.EventNameSpaces.ERROR][table] = cb;
  }
  static subscriber(event, cb) {
    try {
      return DB.connectClient()
        .then(async () => {
          if (!DB.brokerEvents[event]) {
            DB.brokerEvents[event] = cb;
            await DB.client.query(`LISTEN ${event}`);
            if (!DB.notificationRegistered) {
              DB.notificationRegistered = true;
              DB.client.on("notification", (msg) => {
                const { channel, payload, ...rest } = msg;
                const handler = DB.brokerEvents[channel];
                if (handler) {
                  handler({
                    ...rest,
                    data: JSON.parse(payload),
                    channel,
                  });
                }
              });
            }
          }
          return async () => await DB.client.query(`UNLISTEN ${event}`);
        })
        .catch((err) => {
          console.log(err);
          return async () => await DB.client.query(`UNLISTEN ${event}`);
        });
    } catch (error) {
      return async () => await DB.client.query(`UNLISTEN ${event}`);
    }
  }
  static async notify(event, data) {
    try {
      if (DB.clientConnected) {
        await DB.client.query(`NOTIFY ${event}, '${JSON.stringify(data)}'`);
      }
    } catch (error) {}
  }
  static unsubscribeEvent(event) {
    try {
      if (DB.clientConnected) {
        DB.client
          .query(`UNLISTEN ${event}`)
          .then(async () => {
            delete DB.brokerEvents[event];
            if (!Object.keys(DB.brokerEvents).length) {
              await DB.clientDisconnect();
            }
          })
          .catch((err) => {
            throw err;
          });
      }
    } catch (error) {
      console.log(error);
    }
  }
  static unsubscribeAllEvents() {
    try {
      if (DB.clientConnected) {
        DB.client
          .query(`UNLISTEN *`)
          .then(async () => {
            DB.brokerEvents = {};
            await DB.clientDisconnect();
          })
          .catch((err) => {
            throw err;
          });
      }
    } catch (error) {
      console.log(error);
    }
  }
  static executeEvent(table, namespace, data, instance) {
    const handler = DB.events?.[namespace]?.[table];
    if (!handler) {
      return null;
    }
    handler(data, instance);
  }
  static async executeAsyncEvent(table, namespace, data, instance) {
    const handler = DB.asyncEvents?.[namespace]?.[table];
    if (!handler) {
      return null;
    }
    await handler(data, instance);
  }
  static eventExists(table, namespace) {
    return !!DB.events[namespace][table];
  }
  static asyncEventExists(table, namespace) {
    return !!DB.asyncEvents[namespace][table];
  }
  static paginator(page, view, total) {
    page = +page;
    if (isNaN(page) || page <= 0) page = 1;
    view = +view;
    if (isNaN(view) || [1, 5, 10, 12, 25, 50, 100].indexOf(view) === -1)
      view = 10;
    total = +total;
    const limit = Math.ceil(total / view);
    if (page > limit) page = limit;
    if (page <= 0) page = 1;
    return {
      total,
      view,
      page,
      skip: (page - 1) * view,
      limit,
      per_page: view,
    };
  }
  static loadApi(callback) {
    Object.entries(DB.modelFactory).map(callback);
  }
  static runJob({ seconds = 0.001, execPath, isPromise = false, log = false }) {
    DB.scheduler.schedule({ exec: execPath, seconds, isPromise, log });
  }
}
module.exports = DB;
