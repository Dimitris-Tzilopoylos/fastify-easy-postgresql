var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
const { Worker, isMainThread, parentPort } = require("worker_threads");
const ValidationService = require("./validation");
const { v4 } = require("uuid");
class Scheduler {
    static schedule({ seconds = 1, exec, isPromise, log = false }) {
        if (!ValidationService.validateNumber({ value: seconds, min: 0.001 })) {
            throw new Error("Seconds minimum value should be 0.001");
        }
        let worker;
        const id = v4();
        Scheduler.jobs[id] = {
            seconds,
            exec,
            isPromise,
            id,
            status: Scheduler.JobStates.CREATED,
        };
        exec = exec.split("\\").join("/");
        if (!isPromise) {
            worker = new Worker(`
        const { parentPort } = require('worker_threads');
        const exec = require('${exec}');
        let isRunning = false
        setInterval(async () => {
          if (!isRunning) {
            isRunning = true;
            parentPort.postMessage('${Scheduler.JobStates.RUNNING}')
            exec();
            parentPort.postMessage('${Scheduler.JobStates.COMPLETED}')
            isRunning = false;
          } else {
            if (log) {
              console.log('Skipping next cycle: Job ${id} already running!');
            }
          }
        }, ${seconds * 1000})`, {
                eval: true,
            });
            Scheduler.jobs[id].terminate = worker.terminate.bind(worker);
        }
        else {
            worker = new Worker(`
        const {parentPort} = require('worker_threads')
        const exec = require('${exec}')
        let isRunning = false
        setInterval(async () => {
          if (!isRunning) {
            isRunning = true;
            parentPort.postMessage('${Scheduler.JobStates.RUNNING}')
            await exec();
            parentPort.postMessage('${Scheduler.JobStates.COMPLETED}')
            isRunning = false;
          } else {
            if (log) {
              console.log('Skipping next cycle: Job ${id} already running!');
            }
          }
        }, ${seconds * 1000})`, {
                eval: true,
            });
            Scheduler.jobs[id].terminate = worker.terminate.bind(worker);
        }
        Scheduler.jobs[id].threadId = worker.threadId;
        Scheduler.jobs[id].worker = worker;
        worker.on("message", (status) => {
            Scheduler.setJobStatusByID(id, status);
        });
        worker.on("error", (err) => {
            if (log) {
                console.table([
                    `Background Worker Error: Job ${id}`,
                    err.name,
                    err.message,
                ]);
            }
        });
        worker.on("exit", (exitCode) => {
            if (log) {
                console.table([
                    `Background Worker Exited: Job ${id}!`,
                    `Exit Code ${exitCode}`,
                ]);
            }
        });
    }
    static getJobs() {
        return Scheduler.jobs;
    }
    static getJobsToArray() {
        return Object.values(Scheduler.jobs).map((_a) => {
            var { worker, terminate } = _a, rest = __rest(_a, ["worker", "terminate"]);
            return rest;
        });
    }
    static getJobIds() {
        return Object.keys(Scheduler.jobs);
    }
    static getJobStateByID(id) {
        var _a, _b;
        return (_b = (_a = Scheduler.jobs) === null || _a === void 0 ? void 0 : _a[id]) === null || _b === void 0 ? void 0 : _b.status;
    }
    static setJobStatusByID(id, status) {
        try {
            Scheduler.jobs[id].status = status;
        }
        catch (error) { }
    }
    static terminateJobByID(id) {
        try {
            const { threadId } = Scheduler.jobs[id];
            console.log(`Terminating worker ${threadId} of Job: ${id}`);
            Scheduler.jobs[id].terminate().then(() => {
                Scheduler.removeJobByID(id);
                console.log(`Worker ${threadId} terminated`);
            });
            return id;
        }
        catch (error) {
            console.log(`Job ${id} was not found or the background worker was not attached yet`);
            return null;
        }
    }
    static removeJobByID(id) {
        try {
            delete Scheduler.jobs[id];
        }
        catch (error) { }
    }
}
Scheduler.jobs = {};
Scheduler.JobStates = {
    CREATED: "CREATED",
    RUNNING: "RUNNING",
    SKIPPED: "SKIPPED",
    COMPLETED: "COMPLETED",
    ERROR: "ERROR",
    EXIT: "EXIT",
};
module.exports = Scheduler;
