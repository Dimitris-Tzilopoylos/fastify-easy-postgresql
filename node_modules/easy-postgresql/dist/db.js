var __awaiter =
  (this && this.__awaiter) ||
  function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P
        ? value
        : new P(function (resolve) {
            resolve(value);
          });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done
          ? resolve(result.value)
          : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
var __rest =
  (this && this.__rest) ||
  function (s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
        if (
          e.indexOf(p[i]) < 0 &&
          Object.prototype.propertyIsEnumerable.call(s, p[i])
        )
          t[p[i]] = s[p[i]];
      }
    return t;
  };
const Column = require("./column");
const {
  WHERE_CLAUSE_OPERATORS,
  QUERY_BINDER_KEYS,
  REQUIRE_CAST_TO_NULL,
  REQUIRE_WILDCARD_TRANSFORMATION,
  IS_POSTGRES,
  SupportedAggregations,
  START_TRANSACTION,
  COMMIT,
  ROLLBACK,
  SELF_UPDATE_OPERATORS,
  EVENTS,
  REQUIRE_ARRAY_TRANSFORMATION,
} = require("./constants");
const { Pool, types, Client } = require("pg");
const { EventEmitter } = require("events");
const Scheduler = require("./scheduler");
types.setTypeParser(types.builtins.INT8, (x) => {
  return x && DB.isString(x) && x.length > 16 ? x : parseInt(x);
});
class DB {
  constructor(connection = null) {
    this.connection = connection;
    this.connected = !!connection;
    this.transaction = false;
    this.database = DB.database;
    this.driver = null;
  }
  static connectClient() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!DB.clientConnected) {
        try {
          DB.clientConnected = true;
          yield DB.client.connect();
        } catch (error) {
          DB.clientConnected = false;
        }
      }
    });
  }
  static clientDisconnect() {
    return __awaiter(this, void 0, void 0, function* () {
      if (DB.clientConnected) {
        yield DB.client.end();
        DB.clientConnected = false;
      }
    });
  }
  connect() {
    return __awaiter(this, void 0, void 0, function* () {
      if (this.connected) {
        return;
      }
      this.connection = yield DB.pool.connect();
      this.connected = true;
    });
  }
  disconnect() {
    if (!this.connected) {
      return;
    }
    if (this.transaction) {
      this.rollback()
        .then((x) => {
          this.connection.release();
          this.connected = false;
          this.transaction = false;
        })
        .catch((err) => {
          this.connection.release();
          this.connected = false;
          this.transaction = false;
        });
    } else {
      this.connection.release();
      this.connected = false;
      this.transaction = false;
    }
  }
  startTransaction() {
    return __awaiter(this, void 0, void 0, function* () {
      yield this.connection.query(START_TRANSACTION);
      this.transaction = true;
    });
  }
  commit() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.transaction) {
        return;
      }
      yield this.connection.query(COMMIT);
      this.transaction = false;
    });
  }
  rollback() {
    return __awaiter(this, void 0, void 0, function* () {
      if (!this.transaction) {
        return;
      }
      yield this.connection.query(ROLLBACK);
      this.transaction = false;
    });
  }
  withTransaction(cb) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield this.connect();
        yield this.startTransaction();
        const result = yield cb(this.connection);
        yield this.commit();
        this.disconnect();
        return result;
      } catch (error) {
        yield this.rollback();
        this.disconnect();
        return error;
      }
    });
  }
  selectQueryExec(sql, args = []) {
    return __awaiter(this, void 0, void 0, function* () {
      const {
        rows: [result],
      } = this.connection
        ? yield this.connection.query(sql, args)
        : yield DB.pool.query(sql, args);
      return result;
    });
  }
  insertQueryExec(sql, args) {
    return __awaiter(this, void 0, void 0, function* () {
      const { rows } = this.connection
        ? yield this.connection.query(sql, args)
        : yield DB.pool.query(sql, args);
      return rows;
    });
  }
  updateQueryExec(sql, args) {
    return __awaiter(this, void 0, void 0, function* () {
      const { rows } = this.connection
        ? yield this.connection.query(sql, args)
        : yield DB.pool.query(sql, args);
      return rows;
    });
  }
  deleteQueryExec(sql, args) {
    return __awaiter(this, void 0, void 0, function* () {
      const { rows } = this.connection
        ? yield this.connection.query(sql, args)
        : yield DB.pool.query(sql, args);
      return rows;
    });
  }
  raw(sql, args = []) {
    return __awaiter(this, void 0, void 0, function* () {
      return yield DB.pool.query(sql, args);
    });
  }
  findOne({
    where = {},
    include = {},
    aggregate = null,
    orderBy,
    groupBy,
    distinct,
  } = {}) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const [result] = yield this.find({
          where,
          include,
          aggregate,
          orderBy,
          groupBy,
          distinct,
          limit: 1,
        });
        return result;
      } catch (error) {
        throw error;
      }
    });
  }
  find({
    where = {},
    include = {},
    aggregate = null,
    orderBy,
    groupBy,
    distinct,
    limit,
    offset,
  } = {}) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        let depth = 0;
        let index = 1;
        const alias = this.makeDepthAlias(this.table, depth);
        const args = [];
        const modelColumnsStr = this.getModelColumnsCommaSeperatedString(alias);
        const selectColumnsStr = [modelColumnsStr]
          .concat(
            Object.keys(include).map(
              (alias, idx) => `${this.makeDepthAlias(alias, 1 + idx)}.${alias}`
            )
          )
          .join(",");
        let sql = `SELECT coalesce(json_agg(${alias}),'[]') as ${this.table} 
        FROM (
          SELECT row_to_json((
            SELECT ${alias}
            FROM ( SELECT ${selectColumnsStr}) ${alias} )) ${alias}
            FROM (
              SELECT ${this.makeDistinctOn(
                distinct,
                alias
              )} ${modelColumnsStr} FROM ${DB.database}.${this.table} ${alias}`;
        const self = this;
        function makeQuery(model, relations, depth, prevAlias) {
          if (!relations || typeof relations === "boolean") {
            return "";
          }
          let sql = ``;
          const _iter = Object.entries(relations);
          for (let i = 0; i < _iter.length; i++) {
            const [_alias, config] = _iter[i];
            const alias = DB.getRelationNameWithoutAggregate(_alias);
            const isAggregate = DB.getIsAggregate(_alias);
            const relation = model.relations[alias];
            if (!relation) {
              throw new Error("no such relation");
            }
            const currentModel = DB.getRelatedModel(relation.to_table);
            if (!currentModel) {
              throw new Error(`no such model for table ${relation.to_table}`);
            }
            const depthAlias = isAggregate
              ? self.makeDepthAlias(relation.alias, depth + i) + "_aggregate"
              : self.makeDepthAlias(relation.alias, depth + i);
            const coalesceFallback = relation.type === "object" ? "null" : "[]";
            const coalesceAppendex = relation.type === "object" ? "->0" : "";
            const modelColumnsStr =
              currentModel.getModelColumnsCommaSeperatedString(depthAlias);
            const {
              distinct,
              groupBy,
              orderBy,
              where,
              include,
              limit,
              offset,
            } = DB.isObject(config) ? config : {};
            const selectColumnsStr = [modelColumnsStr]
              .concat(
                Object.keys(include || {}).map(
                  (alias, idx) =>
                    `${self.makeDepthAlias(alias, depth + 1 + idx)}.${alias}`
                )
              )
              .join(",");
            if (isAggregate) {
              const [agg] = currentModel.aggregateInternal(
                Object.assign(Object.assign({}, config), { alias: depthAlias })
              );
              sql += `
              LEFT JOIN LATERAL  (${agg} 
            `;
            } else {
              sql += ` 
          LEFT OUTER JOIN LATERAL ( SELECT coalesce(json_agg(${depthAlias})${coalesceAppendex},'${coalesceFallback}') as ${
                relation.alias
              } 
          FROM (
            SELECT row_to_json((
              SELECT ${depthAlias}
              FROM ( SELECT ${selectColumnsStr}) ${depthAlias} )) ${depthAlias}
              FROM (
                SELECT ${currentModel.makeDistinctOn(
                  distinct,
                  depthAlias
                )} ${modelColumnsStr} FROM ${DB.database}.${
                currentModel.table
              } ${depthAlias} `;
            }
            const appendSql = makeQuery(
              currentModel,
              include,
              depth + 1,
              depthAlias
            );
            const [whereClauseStr, qArgs, idx] = currentModel.makeWhereClause(
              currentModel,
              where,
              index,
              depthAlias,
              false,
              false
            );
            args.push(...qArgs);
            index = idx;
            const groupByStr = currentModel.makeGroupBy(groupBy, depthAlias);
            const orderByStr = currentModel.makeOrderBy(orderBy, depthAlias);
            const [limitStr, limitArgs, idxLimit] = currentModel.makeLimit(
              limit,
              index
            );
            index = idxLimit;
            args.push(...limitArgs);
            const [offsetStr, offsetArgs, idxOffset] = currentModel.makeOffset(
              offset,
              index
            );
            args.push(...offsetArgs);
            index = idxOffset;
            if (!isAggregate) {
              sql += `
            WHERE ${prevAlias}.${relation.from_column} = ${depthAlias}.${relation.to_column}
            ${whereClauseStr}
            ${groupByStr}
            ${orderByStr}
            ${limitStr}
            ${offsetStr} ) ${depthAlias}  ${appendSql} ) ${depthAlias} ) AS ${depthAlias} ON true
            `;
            } else {
              sql += ` WHERE ${prevAlias}.${relation.from_column} = ${depthAlias}.${relation.to_column}
            ${whereClauseStr}
            ${groupByStr} )   AS ${depthAlias} ON true`;
            }
          }
          return sql;
        }
        const [whereClauseStr, whereArgs, idx] = this.makeWhereClause(
          this,
          where,
          index,
          alias,
          true,
          true
        );
        index = idx;
        args.push(...whereArgs);
        const groupByStr = this.makeGroupBy(groupBy, alias);
        const orderByStr = this.makeOrderBy(orderBy, alias);
        const [limitStr, limitArgs, idxLimit] = this.makeLimit(limit, index);
        index = idxLimit;
        args.push(...limitArgs);
        const [offsetStr, offsetArgs, idxOffset] = this.makeOffset(
          offset,
          index
        );
        args.push(...offsetArgs);
        index = idxOffset;
        sql += `
      ${whereClauseStr}
      ${groupByStr}
      ${orderByStr}
      ${limitStr}
      ${offsetStr} ) ${alias}
      `;
        sql += makeQuery(this, include, depth + 1, alias);
        sql += ` ) ${alias}`;
        if (DB.enableLog) {
          console.log(sql);
        }
        const result =
          (_a = yield this.selectQueryExec(sql, args)) === null || _a === void 0
            ? void 0
            : _a[this.table];
        if (DB.eventExists(this.table, DB.EventNameSpaces.SELECT)) {
          DB.executeEvent(this.table, DB.EventNameSpaces.SELECT, result, this);
        }
        if (DB.asyncEventExists(this.table, DB.EventNameSpaces.SELECT)) {
          yield DB.executeAsyncEvent(
            this.table,
            DB.EventNameSpaces.SELECT,
            result,
            this
          );
        }
        return result;
      } catch (error) {
        if (DB.eventExists(this.table, DB.EventNameSpaces.ERROR)) {
          DB.executeEvent(this.table, DB.EventNameSpaces.ERROR, error, this);
        }
        if (DB.asyncEventExists(this.table, DB.EventNameSpaces.ERROR)) {
          yield DB.executeAsyncEvent(
            this.table,
            DB.EventNameSpaces.ERROR,
            error,
            this
          );
        }
        throw error;
      }
    });
  }
  insert(args) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      if (!DB.isObject(args)) {
        return null;
      }
      try {
        const { onConflict } = args,
          rest = __rest(args, ["onConflict"]);
        const [modelPayload, relationalPayload] =
          this.splitRelationalAndModelColumnsInput(rest);
        const [query, qArgs] = this.buildInsertQuery(modelPayload, onConflict);
        const [result] = yield this.insertQueryExec(query, qArgs);
        const self = this;
        function insertChildren(model, prevResult, relationalPayload) {
          var _a, _b;
          return __awaiter(this, void 0, void 0, function* () {
            const _iter = Object.keys(relationalPayload || {});
            const aggResult = {};
            if (!_iter.length) {
              return aggResult;
            }
            for (let i = 0; i < _iter.length; i++) {
              const relationAlias = _iter[i];
              const insertInput = relationalPayload[relationAlias];
              const relation =
                (_a = model.relations) === null || _a === void 0
                  ? void 0
                  : _a[relationAlias];
              if (!relation) {
                throw new Error("no such relation");
              }
              const insertionModel = DB.getRelatedModel(relation.to_table);
              if (!insertionModel) {
                throw new Error("no such model");
              }
              if (relation.type === "object" && Array.isArray(insertInput)) {
                throw new Error(
                  "relation type object cannot accept an array as input"
                );
              }
              if (relation.type === "array" && !Array.isArray(insertInput)) {
                throw new Error(
                  "relation type array can only accept array inputs"
                );
              }
              const dependedColumnValue = prevResult[relation.from_column];
              const valuesIter =
                relation.type === "object" ? [insertInput] : insertInput;
              const appendResult = [];
              for (let value of valuesIter) {
                value[relation.to_column] = dependedColumnValue;
                const { onConflict } = value,
                  rest = __rest(value, ["onConflict"]);
                const [modelPayload, relationalPayload] =
                  insertionModel.splitRelationalAndModelColumnsInput(rest);
                const [query, args] = insertionModel.buildInsertQuery(
                  modelPayload,
                  onConflict
                );
                const [result] = yield self.insertQueryExec(query, args);
                const childrenResult = yield insertChildren(
                  insertionModel,
                  result,
                  relationalPayload
                );
                if (
                  (_b = Object.keys(childrenResult)) === null || _b === void 0
                    ? void 0
                    : _b.length
                ) {
                  Object.assign(result, childrenResult);
                }
                appendResult.push(result);
              }
              if (relation.type === "object") {
                aggResult[relationAlias] = appendResult[0];
              } else {
                aggResult[relationAlias] = appendResult;
              }
            }
            return aggResult;
          });
        }
        const childrenResult = yield insertChildren(
          this,
          result,
          relationalPayload
        );
        if (
          (_a = Object.keys(childrenResult)) === null || _a === void 0
            ? void 0
            : _a.length
        ) {
          Object.assign(result, childrenResult);
        }
        return result;
      } catch (error) {
        throw error;
      }
    });
  }
  createTX(args) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        yield this.connect();
        const result = yield this.withTransaction((tx) =>
          __awaiter(this, void 0, void 0, function* () {
            return yield this.insert(args);
          })
        );
        this.disconnect();
        if (DB.eventExists(this.table, DB.EventNameSpaces.INSERT)) {
          DB.executeEvent(this.table, DB.EventNameSpaces.INSERT, result, this);
        }
        if (DB.asyncEventExists(this.table, DB.EventNameSpaces.INSERT)) {
          yield DB.executeAsyncEvent(
            this.table,
            DB.EventNameSpaces.INSERT,
            result,
            this
          );
        }
        return result;
      } catch (error) {
        this.disconnect();
        if (DB.eventExists(this.table, DB.EventNameSpaces.ERROR)) {
          DB.executeEvent(this.table, DB.EventNameSpaces.ERROR, error, this);
        }
        if (DB.eventExists(this.table, DB.EventNameSpaces.ERROR)) {
          yield DB.executeAsyncEvent(
            this.table,
            DB.EventNameSpaces.ERROR,
            error,
            this
          );
        }
        throw error;
      }
    });
  }
  createManyTX(args) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (!Array.isArray(args)) {
          throw new Error("provided input is not an array");
        }
        yield this.connect();
        const result = yield this.withTransaction((tx) =>
          __awaiter(this, void 0, void 0, function* () {
            const promises = args.map((input) => this.insert(input));
            return yield Promise.all(promises);
          })
        );
        this.disconnect();
        if (DB.eventExists(this.table, DB.EventNameSpaces.INSERT)) {
          DB.executeEvent(this.table, DB.EventNameSpaces.INSERT, result, this);
        }
        if (DB.asyncEventExists(this.table, DB.EventNameSpaces.INSERT)) {
          yield DB.executeAsyncEvent(
            this.table,
            DB.EventNameSpaces.INSERT,
            result,
            this
          );
        }
        return result;
      } catch (error) {
        this.disconnect();
        if (DB.eventExists(this.table, DB.EventNameSpaces.ERROR)) {
          DB.executeEvent(this.table, DB.EventNameSpaces.ERROR, error, this);
        }
        if (DB.asyncEventExists(this.table, DB.EventNameSpaces.ERROR)) {
          yield DB.executeAsyncEvent(
            this.table,
            DB.EventNameSpaces.ERROR,
            error,
            this
          );
        }
        throw error;
      }
    });
  }
  create(args) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const result = yield this.insert(args);
        if (DB.eventExists(this.table, DB.EventNameSpaces.INSERT)) {
          DB.executeEvent(this.table, DB.EventNameSpaces.INSERT, result, this);
        }
        if (DB.asyncEventExists(this.table, DB.EventNameSpaces.INSERT)) {
          yield DB.executeAsyncEvent(
            this.table,
            DB.EventNameSpaces.INSERT,
            result,
            this
          );
        }
        return result;
      } catch (error) {
        if (DB.eventExists(this.table, DB.EventNameSpaces.ERROR)) {
          DB.executeEvent(this.table, DB.EventNameSpaces.ERROR, error, this);
        }
        if (DB.asyncEventExists(this.table, DB.EventNameSpaces.ERROR)) {
          yield DB.executeAsyncEvent(
            this.table,
            DB.EventNameSpaces.ERROR,
            error,
            this
          );
        }
        throw error;
      }
    });
  }
  createMany(args) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (!Array.isArray(args)) {
          throw new Error("provided input is not an array");
        }
        const promises = args.map((input) => this.insert(input));
        const result = yield Promise.all(promises);
        if (DB.eventExists(this.table, DB.EventNameSpaces.INSERT)) {
          DB.executeEvent(this.table, DB.EventNameSpaces.INSERT, result, this);
        }
        if (DB.asyncEventExists(this.table, DB.EventNameSpaces.INSERT)) {
          yield DB.executeAsyncEvent(
            this.table,
            DB.EventNameSpaces.INSERT,
            result,
            this
          );
        }
        return result;
      } catch (error) {
        if (DB.eventExists(this.table, DB.EventNameSpaces.ERROR)) {
          DB.executeEvent(this.table, DB.EventNameSpaces.ERROR, error, this);
        }
        if (DB.asyncEventExists(this.table, DB.EventNameSpaces.ERROR)) {
          yield DB.executeAsyncEvent(
            this.table,
            DB.EventNameSpaces.ERROR,
            error,
            this
          );
        }
        throw error;
      }
    });
  }
  update({ update, where = {} }) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const [modelColumns] = this.splitRelationalAndModelColumnsInput(
          update,
          Object.keys(SELF_UPDATE_OPERATORS)
        );
        const [columns, qArgs] = Object.entries(modelColumns).reduce(
          (acc, [key, value], idx) => {
            if (SELF_UPDATE_OPERATORS[key]) {
              if (!DB.isObject(value)) {
                throw new Error(
                  "self update operators should have an object value"
                );
              }
              const [selfUpdateColumns] =
                this.splitRelationalAndModelColumnsInput(value);
              acc[0].push(
                ...Object.entries(selfUpdateColumns).map(
                  ([c, val], innerIndex) => {
                    const sql = `${c} = ${c} ${SELF_UPDATE_OPERATORS[key]} $${
                      acc[1].length + 1
                    }`;
                    acc[1].push(val);
                    return sql;
                  }
                )
              );
            } else {
              acc[0].push(`${key} = $${acc[1].length + 1}`);
              acc[1].push(value);
            }
            return acc;
          },
          [[], []]
        );
        const [whereStr, whereArgs] = this.makeWhereClause(
          this,
          where,
          qArgs.length + 1,
          this.table,
          true,
          true
        );
        const sql = `UPDATE ${DB.database}.${this.table} SET ${columns.join(
          ","
        )} ${whereStr} RETURNING *`;
        qArgs.push(...whereArgs);
        const result = yield this.updateQueryExec(sql, qArgs);
        if (DB.eventExists(this.table, DB.EventNameSpaces.UPDATE)) {
          DB.executeEvent(this.table, DB.EventNameSpaces.UPDATE, result, this);
        }
        if (DB.asyncEventExists(this.table, DB.EventNameSpaces.UPDATE)) {
          yield DB.executeAsyncEvent(
            this.table,
            DB.EventNameSpaces.UPDATE,
            result,
            this
          );
        }
        return result;
      } catch (error) {
        if (DB.eventExists(this.table, DB.EventNameSpaces.ERROR)) {
          DB.executeEvent(this.table, DB.EventNameSpaces.ERROR, error, this);
        }
        if (DB.asyncEventExists(this.table, DB.EventNameSpaces.ERROR)) {
          yield DB.executeAsyncEvent(
            this.table,
            DB.EventNameSpaces.ERROR,
            error,
            this
          );
        }
        throw error;
      }
    });
  }
  delete({ where = {} }) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const [whereStr, whereArgs] = this.makeWhereClause(
          this,
          where,
          1,
          this.table,
          true,
          true
        );
        const sql = `DELETE FROM ${DB.database}.${this.table} ${whereStr} RETURNING *`;
        const result = yield this.deleteQueryExec(sql, whereArgs);
        if (DB.eventExists(this.table, DB.EventNameSpaces.DELETE)) {
          DB.executeEvent(this.table, DB.EventNameSpaces.DELETE, result, this);
        }
        if (DB.asyncEventExists(this.table, DB.EventNameSpaces.DELETE)) {
          yield DB.executeAsyncEvent(
            this.table,
            DB.EventNameSpaces.DELETE,
            result,
            this
          );
        }
        return result;
      } catch (error) {
        if (DB.eventExists(this.table, DB.EventNameSpaces.ERROR)) {
          DB.executeEvent(this.table, DB.EventNameSpaces.ERROR, error, this);
        }
        if (DB.asyncEventExists(this.table, DB.EventNameSpaces.ERROR)) {
          yield DB.executeAsyncEvent(
            this.table,
            DB.EventNameSpaces.ERROR,
            error,
            this
          );
        }
        throw error;
      }
    });
  }
  aggregate({ where, groupBy, distinct, _count, _max, _min, _sum, _avg } = {}) {
    var _a;
    return __awaiter(this, void 0, void 0, function* () {
      try {
        const countAgg = this.buildCountAgg(_count);
        const aggregations = [
          { key: "_min", value: _min },
          { key: "_max", value: _max },
          { key: "_sum", value: _sum },
          { key: "_avg", value: _avg },
        ]
          .map((x) => this.buildAgg(x.value, x.key))
          .concat(countAgg)
          .filter(Boolean)
          .join(",");
        if (!aggregations.length) {
          throw new Error("no aggregations were found for this operation");
        }
        const [whereStr, whereArgs] = this.makeWhereClause(
          this,
          where,
          1,
          this.table,
          true,
          true
        );
        const groupByStr = this.makeGroupBy(groupBy, this.table);
        const distinctStr = this.makeDistinctOn(distinct, this.table);
        const sql = `SELECT ${distinctStr} json_build_object(${aggregations})  as ${this.table}_aggregate FROM ${DB.database}.${this.table}  ${whereStr} ${groupByStr}`;
        return (_a = yield this.selectQueryExec(sql, whereArgs)) === null ||
          _a === void 0
          ? void 0
          : _a[`${this.table}_aggregate`];
      } catch (error) {
        throw error;
      }
    });
  }
  aggregateInternal({
    where,
    groupBy,
    distinct,
    _count,
    _max,
    _min,
    _sum,
    _avg,
    index = 1,
    alias,
    withWhere = false,
  } = {}) {
    try {
      const countAgg = this.buildCountAgg(_count);
      const aggregations = [
        { key: "_min", value: _min },
        { key: "_max", value: _max },
        { key: "_sum", value: _sum },
        { key: "_avg", value: _avg },
      ]
        .map((x) => this.buildAgg(x.value, x.key))
        .concat(countAgg)
        .filter(Boolean)
        .join(",");
      if (!aggregations.length) {
        throw new Error("no aggregations were found for this operation");
      }
      if (withWhere) {
        const [whereStr, whereArgs, idx] = this.makeWhereClause(
          this,
          where,
          index,
          alias,
          true,
          true
        );
        const groupByStr = this.makeGroupBy(groupBy, this.table);
        const distinctStr = this.makeDistinctOn(distinct, this.table);
        const sql = `SELECT ${distinctStr} json_build_object(${aggregations})  as ${this.table}_aggregate FROM ${DB.database}.${this.table} as ${alias}  ${whereStr} ${groupByStr}`;
        return [sql, whereArgs, idx];
      }
      const groupByStr = this.makeGroupBy(groupBy, this.table);
      const distinctStr = this.makeDistinctOn(distinct, this.table);
      const sql = `SELECT ${distinctStr} json_build_object(${aggregations})  as ${this.table}_aggregate FROM ${DB.database}.${this.table} as ${alias} ${groupByStr}`;
      return [sql, "", index];
    } catch (error) {
      throw error;
    }
  }
  buildCountAgg(count) {
    if (!count) {
      return;
    }
    return `'count',COUNT(*)`;
  }
  buildAgg(aggConfig, key) {
    if (!DB.isObject(aggConfig)) {
      return;
    }
    const [modelColumns] = this.splitRelationalAndModelColumnsInput(aggConfig);
    const columns = Object.keys(modelColumns).filter((x) => !!modelColumns[x]);
    if (!columns.length) {
      return [];
    }
    return `'${SupportedAggregations[
      key
    ].toLowerCase()}',json_build_object(${columns
      .map((column) => `'${column}',${SupportedAggregations[key]}(${column})`)
      .join(",")})`;
  }
  buildInsertQuery(args, onConflict) {
    if (!DB.isObject(args)) {
      throw new Error();
    }
    const [columns, placeholders, qArgs] = Object.entries(args).reduce(
      (acc, [key, value], idx) => {
        acc[0].push(key);
        acc[1].push(`$${idx + 1}`);
        acc[2].push(value);
        return acc;
      },
      [[], [], []]
    );
    return [
      `INSERT INTO ${DB.database}.${this.table} (${columns.join(
        ","
      )}) VALUES(${placeholders.join(",")}) RETURNING *`,
      qArgs,
    ];
  }
  makeDistinctOn(distinct, alias) {
    if (
      !Array.isArray(distinct) ||
      !(distinct === null || distinct === void 0 ? void 0 : distinct.length)
    ) {
      return "";
    }
    const strFields = distinct
      .filter((col) => !!this.columns[col])
      .map((col) => `${alias ? `${alias}.` : ""}${col.column}`)
      .join(",");
    if (!strFields.length) {
      return "";
    }
    return `DISTINCT ON (${strFields})`;
  }
  makeWhereClause(
    model,
    where,
    index,
    alias,
    isFirstEntry = true,
    startWithWhere = true,
    binder = "AND",
    depth = 0
  ) {
    if (!model || !where || !DB.isObject(where)) {
      return ["", [], index];
    }
    const args = [];
    let _iter = Object.entries(where);
    if (!(_iter === null || _iter === void 0 ? void 0 : _iter.length)) {
      return ["", [], index];
    }
    let sql = startWithWhere && _iter.length ? "WHERE" : "";
    function getFirstEntry(isFirstEntry, operator) {
      if (isFirstEntry) {
        return "";
      }
      return operator || WHERE_CLAUSE_OPERATORS._and;
    }
    for (let y = 0; y < _iter.length; y++) {
      const [key, config] = _iter[y];
      if (QUERY_BINDER_KEYS[key]) {
        if (!Array.isArray(config)) {
          throw new Error(
            "No Array provided for query logical binder operation"
          );
        }
        if (!config.length) {
          continue;
        }
        sql += ` ${getFirstEntry(isFirstEntry, binder)} ( `;
        for (let i = 0; i < config.length; i++) {
          const entry = config[i];
          const [str, qArgs, idx] = this.makeWhereClause(
            model,
            entry,
            index,
            alias,
            i === 0,
            false,
            WHERE_CLAUSE_OPERATORS[key]
          );
          sql += `${str}`;
          args.push(...qArgs);
          index = idx;
        }
        sql += `)`;
      } else if (WHERE_CLAUSE_OPERATORS[key]) {
        if (REQUIRE_CAST_TO_NULL[key]) {
          sql += ` ${WHERE_CLAUSE_OPERATORS[key]} NULL`;
        } else if (REQUIRE_WILDCARD_TRANSFORMATION[key]) {
          sql += ` ${WHERE_CLAUSE_OPERATORS[key]} $${index}`;
          args.push(`%${config}%`);
          index++;
        } else if (REQUIRE_ARRAY_TRANSFORMATION[key]) {
          sql += ` ${WHERE_CLAUSE_OPERATORS[key]} ($${index})`;
          args.push(config);
          index++;
        } else {
          if (config instanceof Column) {
            sql += ` ${WHERE_CLAUSE_OPERATORS[key]} ${
              config.alias ? "" : `${alias}.`
            }${config.column}`;
          } else {
            sql += ` ${WHERE_CLAUSE_OPERATORS[key]} $${index}`;
            args.push(config);
            index++;
          }
        }
      } else if (model.columns[key]) {
        const [isArrayComparison, sqlSTR, arrayKey] =
          model.isArrayComparison(config);
        if (isArrayComparison) {
          sql += ` ${getFirstEntry(
            isFirstEntry,
            binder
          )} $${index} ${sqlSTR}(${alias}.${model.columns[key].column}) `;
          index++;
          args.push(config[arrayKey]);
          continue;
        }
        sql += ` ${getFirstEntry(isFirstEntry, binder)} ${alias}.${
          model.columns[key].column
        }`;
        const [qStr, qArgs, idx] = this.makeWhereClause(
          model,
          config,
          index,
          alias,
          isFirstEntry,
          false,
          binder
        );
        sql += qStr;
        args.push(...qArgs);
        index = idx;
      } else if (model.relations[key]) {
        const currentModel = DB.getRelatedModel(
          DB.models[model.relations[key].to_table].table
        );
        const relation = model.relations[key];
        const newAlias = this.makeDepthAlias(relation.alias, depth);
        sql += ` ${getFirstEntry(isFirstEntry, binder)} ${alias}.${
          relation.from_column
        } IN (SELECT ${relation.to_column} FROM ${DB.database}.${
          currentModel.table
        } ${newAlias} WHERE ${alias}.${relation.from_column} = ${newAlias}.${
          relation.to_column
        }`;
        const [qString, qArgs, idx] = currentModel.makeWhereClause(
          currentModel,
          where[key],
          index,
          newAlias,
          false,
          false,
          binder,
          depth + 1
        );
        sql += ` ${qString} )`;
        args.push(...qArgs);
        index = idx;
      } else {
        throw new Error("UNKNOWN OPERATION");
      }
      isFirstEntry = false;
    }
    return [sql, args, index];
  }
  isArrayComparison(config) {
    const ok =
      !!(config === null || config === void 0 ? void 0 : config._in_array) ||
      !!(config === null || config === void 0 ? void 0 : config._nin_array);
    if (!ok) {
      return [ok, undefined];
    }
    const sqlSTR = !!(config === null || config === void 0
      ? void 0
      : config._in_array)
      ? WHERE_CLAUSE_OPERATORS._in_array
      : WHERE_CLAUSE_OPERATORS._nin_array;
    return [
      ok,
      sqlSTR,
      !!(config === null || config === void 0 ? void 0 : config._in_array)
        ? "_in_array"
        : "_nin_array",
    ];
  }
  makeGroupBy(groupBy, alias) {
    if (
      !Array.isArray(groupBy) ||
      !(groupBy === null || groupBy === void 0 ? void 0 : groupBy.length)
    ) {
      return "";
    }
    const strFields = groupBy
      .filter((col) => !!this.columns[col])
      .map((col) => `${alias ? `${alias}.` : ""}${col.column}`)
      .join(",");
    if (!strFields.length) {
      return "";
    }
    return `GROUP BY (${strFields})`;
  }
  makeOrderBy(orderBy, alias = "") {
    if (!orderBy) {
      return "";
    }
    const orderByStr = Object.entries(orderBy || {})
      .reduce((acc, [key, value]) => {
        if (!this.columns[key]) {
          return acc;
        }
        acc.push(
          ` ${alias ? `${alias}.` : ""}${key}  ${
            DB.allowedOrderDirectionsKeys[value] || "ASC"
          }`
        );
        return acc;
      }, [])
      .join(",");
    return this.combineOrderBy(
      orderByStr,
      this.getAggregationForSorting(orderBy, alias)
    );
  }
  makeLimit(limit, index) {
    if (DB.isNullOrUndefinedOrEmpty(limit)) {
      return ["", [], index];
    }
    return [`LIMIT $${index}`, [limit], index + 1];
  }
  makeOffset(offset, index) {
    if (DB.isNullOrUndefinedOrEmpty(offset)) {
      return ["", [], index];
    }
    return [`OFFSET $${index}`, [offset], index + 1];
  }
  getAggregationForSorting(orderBy, currentAlias) {
    if (!DB.isObject(orderBy)) {
      return "";
    }
    const columnsForOrdering = Object.keys(orderBy).reduce((acc, key) => {
      var _a;
      const isAggregation = DB.getIsAggregate(key);
      if (!isAggregation) {
        return acc;
      }
      const relationalAlias = DB.getRelationNameWithoutAggregate(key);
      const relation =
        (_a = this.relations) === null || _a === void 0
          ? void 0
          : _a[relationalAlias];
      if (!relation) {
        return acc;
      }
      const currModel = DB.getRelatedModel(relation.to_table);
      if (!currModel) {
        return acc;
      }
      acc = acc.concat(
        currModel.produceOrderByForAggregations(
          orderBy[key],
          currentAlias,
          relation
        )
      );
      return acc;
    }, []);
    return columnsForOrdering.join(",");
  }
  combineOrderBy(orderByColumnsString, orderByAggregationsString) {
    if (!orderByAggregationsString && !orderByColumnsString) {
      return "";
    }
    return `ORDER BY ${orderByColumnsString} ${
      orderByColumnsString && orderByAggregationsString
        ? `,${orderByAggregationsString}`
        : orderByAggregationsString
    }`;
  }
  produceOrderByForAggregations(aggrConfig, prevAlias, relation) {
    const { _count } = aggrConfig,
      rest = __rest(aggrConfig, ["_count"]);
    let queries = [];
    const table = `${DB.database}.${this.table} `;
    const whereClause = `${prevAlias}.${relation.from_column} = ${this.table}.${relation.to_column}`;
    if (_count) {
      queries.push(
        ` (SELECT  COUNT(*) FROM ${table} WHERE ${whereClause} ) ${
          DB.allowedOrderDirectionsKeys[_count] || "ASC"
        }`
      );
    }
    Object.entries(rest).forEach(([key, value]) => {
      if (!SupportedAggregations[key]) {
        throw { message: `Invalid aggregation type ${key}`, status: 400 };
      }
      queries = queries.concat(
        this.toOrderByByAggregationConfig({
          columnsMap: this.columns,
          aggregationKey: SupportedAggregations[key],
          table,
          whereClause,
          aggrKeyConfig: value,
        })
      );
    });
    return queries;
  }
  toOrderByByAggregationConfig({
    columnsMap,
    aggregationKey,
    aggrKeyConfig,
    table,
    whereClause,
  }) {
    return Object.keys(aggrKeyConfig).map((column) => {
      if (!columnsMap[column]) {
        throw { message: `Column ${column} doesn't exist`, status: 400 };
      }
      return `(SELECT ${aggregationKey}(${column}) FROM ${table} WHERE ${whereClause}) ${
        DB.allowedOrderDirectionsKeys[aggrKeyConfig[column]] || "ASC"
      }`;
    });
  }
  makeColumnAlias(col) {
    var _a;
    if (
      (_a = col === null || col === void 0 ? void 0 : col.name) === null ||
      _a === void 0
        ? void 0
        : _a.startsWith(this.table)
    ) {
      return col;
    }
    return `${this.table}.${col.name}`;
  }
  makeDepthAlias(alias, depth) {
    return `_${depth}_${alias}`;
  }
  splitRelationalAndModelColumnsInput(args, allowedEntries = []) {
    return Object.entries(args).reduce(
      (acc, [key, value]) => {
        if (!this.columns[key] && !this.relations[key]) {
          if (!allowedEntries.length) {
            return acc;
          }
        }
        if (this.columns[key]) {
          acc[0][key] = value;
        } else if (allowedEntries.indexOf(key) !== -1) {
          acc[0][key] = value;
        } else {
          acc[1][key] = value;
        }
        return acc;
      },
      [{}, {}]
    );
  }
  static register(model) {
    const invoked = new model();
    DB.models[invoked.table] = new model();
    DB.modelFactory[invoked.table] = model;
    const aggModel = new model();
    aggModel.isAggregate = true;
    DB.models[`${invoked.table}_aggregate`] = aggModel;
  }
  static registerDatabase(db) {
    DB.database = db;
  }
  static registerConnectionConfig(connectionConfig = {}) {
    if (DB.pool) {
      DB.pool.end();
    }
    DB.connectionConfig = Object.assign(
      Object.assign({}, DB.connectionConfig),
      connectionConfig
    );
    DB.pool = new Pool(DB.connectionConfig);
    DB.client = new Client(DB.connectionConfig);
  }
  static getRelatedModel(table) {
    return DB.models[table];
  }
  getRelatedModelByAlias(alias) {
    var _a;
    return (_a = this === null || this === void 0 ? void 0 : this.relations) ===
      null || _a === void 0
      ? void 0
      : _a[alias];
  }
  static getIsAggregate(alias) {
    return alias === null || alias === void 0
      ? void 0
      : alias.endsWith("_aggregate");
  }
  static getRelationNameWithoutAggregate(alias) {
    if (!alias) {
      return "";
    }
    return alias.split("_aggregate")[0];
  }
  static isObject(value) {
    return (
      !this.isNullOrUndefined(value) &&
      !Array.isArray(value) &&
      typeof value === "object"
    );
  }
  static isUndefined(value) {
    return typeof value === "undefined";
  }
  static isNull(value) {
    var _a;
    return (
      value === null ||
      (this.isString(value) &&
        ((_a =
          value === null || value === void 0 ? void 0 : value.toLowerCase()) ===
          null || _a === void 0
          ? void 0
          : _a.trim()) === "null")
    );
  }
  static isString(value) {
    return typeof value === "string";
  }
  static isNullOrUndefined(value) {
    return this.isNull(value) || this.isUndefined(value);
  }
  static isNullOrUndefinedOrEmpty(value) {
    return this.isNull(value) || this.isUndefined(value) || value === "";
  }
  static onSelect(table, cb) {
    DB.events[DB.EventNameSpaces.SELECT][table] = cb;
  }
  static onInsert(table, cb) {
    DB.events[DB.EventNameSpaces.INSERT][table] = cb;
  }
  static onUpdate(table, cb) {
    DB.events[DB.EventNameSpaces.UPDATE][table] = cb;
  }
  static onDelete(table, cb) {
    DB.events[DB.EventNameSpaces.DELETE][table] = cb;
  }
  static onError(table, cb) {
    DB.events[DB.EventNameSpaces.ERROR][table] = cb;
  }
  static onSelectAsync(table, cb) {
    DB.asyncEvents[DB.EventNameSpaces.SELECT][table] = cb;
  }
  static onInsertAsync(table, cb) {
    DB.asyncEvents[DB.EventNameSpaces.INSERT][table] = cb;
  }
  static onUpdateAsync(table, cb) {
    DB.asyncEvents[DB.EventNameSpaces.UPDATE][table] = cb;
  }
  static onDeleteAsync(table, cb) {
    DB.asyncEvents[DB.EventNameSpaces.DELETE][table] = cb;
  }
  static onErrorAsync(table, cb) {
    DB.asyncEvents[DB.EventNameSpaces.ERROR][table] = cb;
  }
  static subscriber(event, cb) {
    try {
      return DB.connectClient()
        .then(() =>
          __awaiter(this, void 0, void 0, function* () {
            if (!DB.brokerEvents[event]) {
              DB.brokerEvents[event] = cb;
              yield DB.client.query(`LISTEN ${event}`);
              if (!DB.notificationRegistered) {
                DB.notificationRegistered = true;
                DB.client.on("notification", (msg) => {
                  const { channel, payload } = msg,
                    rest = __rest(msg, ["channel", "payload"]);
                  const handler = DB.brokerEvents[channel];
                  if (handler) {
                    handler(
                      Object.assign(Object.assign({}, rest), {
                        data: JSON.parse(payload),
                        channel,
                      })
                    );
                  }
                });
              }
            }
            return () =>
              __awaiter(this, void 0, void 0, function* () {
                return yield DB.client.query(`UNLISTEN ${event}`);
              });
          })
        )
        .catch((err) => {
          console.log(err);
          return () =>
            __awaiter(this, void 0, void 0, function* () {
              return yield DB.client.query(`UNLISTEN ${event}`);
            });
        });
    } catch (error) {
      return () =>
        __awaiter(this, void 0, void 0, function* () {
          return yield DB.client.query(`UNLISTEN ${event}`);
        });
    }
  }
  static notify(event, data) {
    return __awaiter(this, void 0, void 0, function* () {
      try {
        if (DB.clientConnected) {
          yield DB.client.query(`NOTIFY ${event}, '${JSON.stringify(data)}'`);
        }
      } catch (error) {}
    });
  }
  static unsubscribeEvent(event) {
    try {
      if (DB.clientConnected) {
        DB.client
          .query(`UNLISTEN ${event}`)
          .then(() =>
            __awaiter(this, void 0, void 0, function* () {
              delete DB.brokerEvents[event];
              if (!Object.keys(DB.brokerEvents).length) {
                yield DB.clientDisconnect();
              }
            })
          )
          .catch((err) => {
            throw err;
          });
      }
    } catch (error) {
      console.log(error);
    }
  }
  static unsubscribeAllEvents() {
    try {
      if (DB.clientConnected) {
        DB.client
          .query(`UNLISTEN *`)
          .then(() =>
            __awaiter(this, void 0, void 0, function* () {
              DB.brokerEvents = {};
              yield DB.clientDisconnect();
            })
          )
          .catch((err) => {
            throw err;
          });
      }
    } catch (error) {
      console.log(error);
    }
  }
  static executeEvent(table, namespace, data, instance) {
    var _a, _b;
    const handler =
      (_b =
        (_a = DB.events) === null || _a === void 0 ? void 0 : _a[namespace]) ===
        null || _b === void 0
        ? void 0
        : _b[table];
    if (!handler) {
      return null;
    }
    handler(data, instance);
  }
  static executeAsyncEvent(table, namespace, data, instance) {
    var _a, _b;
    return __awaiter(this, void 0, void 0, function* () {
      const handler =
        (_b =
          (_a = DB.asyncEvents) === null || _a === void 0
            ? void 0
            : _a[namespace]) === null || _b === void 0
          ? void 0
          : _b[table];
      if (!handler) {
        return null;
      }
      yield handler(data, instance);
    });
  }
  static eventExists(table, namespace) {
    return !!DB.events[namespace][table];
  }
  static asyncEventExists(table, namespace) {
    return !!DB.asyncEvents[namespace][table];
  }
  static paginator(page, view, total) {
    page = +page;
    if (isNaN(page) || page <= 0) page = 1;
    view = +view;
    if (isNaN(view) || [1, 5, 10, 12, 25, 50, 100].indexOf(view) === -1)
      view = 10;
    total = +total;
    const limit = Math.ceil(total / view);
    if (page > limit) page = limit;
    if (page <= 0) page = 1;
    return {
      total,
      view,
      page,
      skip: (page - 1) * view,
      limit,
      per_page: view,
    };
  }
  static loadApi(callback) {
    Object.entries(DB.modelFactory).map(callback);
  }
  static runJob({ seconds = 0.001, execPath, isPromise = false, log = false }) {
    DB.scheduler.schedule({ exec: execPath, seconds, isPromise, log });
  }
}
DB.models = {};
DB.modelFactory = {};
DB.database = {};
DB.enableLog = false;
DB.scheduler = Scheduler;
DB.allowedOrderDirectionsKeys = Object.assign(
  { ASC: "ASC", DESC: "DESC", asc: "ASC", desc: "DESC" },
  IS_POSTGRES && {
    asc_nulls_first: "ASC NULLS FIRST",
    asc_nulls_last: "ASC NULLS LAST",
    desc_nulls_first: "DESC NULLS FIRST",
    desc_nulls_last: "DESC NULLS LAST",
  }
);
DB.connectionConfig = {
  host: process.env.DB_HOST,
  port: process.env.DB_PORT,
  user: process.env.DB_USER,
  password: process.env.DB_PASSWORD,
  database: process.env.DB_NAME,
  max: 50,
  min: 0,
  idleTimeoutMillis: 0,
  connectionTimeoutMillis: 0,
  statement_timeout: 20000,
};
DB.EventNameSpaces = EVENTS;
DB.pool = new Pool(DB.connectionConfig);
DB.client = new Client(DB.connectionConfig);
DB.clientConnected = false;
DB.brokerEvents = {};
DB.notificationRegistered = false;
DB.events = {
  [EVENTS.SELECT]: {},
  [EVENTS.INSERT]: {},
  [EVENTS.UPDATE]: {},
  [EVENTS.DELETE]: {},
  [EVENTS.ERROR]: {},
};
DB.asyncEvents = {
  [EVENTS.SELECT]: {},
  [EVENTS.INSERT]: {},
  [EVENTS.UPDATE]: {},
  [EVENTS.DELETE]: {},
  [EVENTS.ERROR]: {},
};
DB.emitter = new EventEmitter();
module.exports = DB;
