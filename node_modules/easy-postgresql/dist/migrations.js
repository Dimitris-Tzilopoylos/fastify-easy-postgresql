var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const fs = require("fs");
const path = require("path");
const prompt = require("prompt-sync")({ sigint: true });
const DBManager = require("./DBManager");
const { Query } = require("pg");
const { v4 } = require("uuid");
class Migrations {
    static migrationsFolderExists() {
        return fs.existsSync(Migrations.resolvePath(Migrations.migrationsFolder));
    }
    static resolvePath(...entries) {
        return path.join(process.cwd(), ...entries);
    }
    static createMigrationsFolder() {
        if (Migrations.migrationsFolderExists()) {
            return;
        }
        fs.mkdirSync(Migrations.resolvePath(Migrations.migrationsFolder));
    }
    static setMigrationsFolder(name) {
        Migrations.migrationsFolder = name;
    }
    static runNewMigration(cb) {
        return __awaiter(this, void 0, void 0, function* () {
            const { up, down, args = [] } = yield cb();
            const filename = `${new Date().getTime()}__migration.json`;
            fs.writeFileSync(Migrations.resolvePath(Migrations.migrationsFolder, filename), JSON.stringify({
                filename,
                up,
                down,
                timestamp: new Date().toUTCString(),
                id: v4(),
                applied: true,
                args,
            }));
        });
    }
    static readMigrationFiles() {
        const files = [];
        fs.readdirSync(Migrations.resolvePath(Migrations.migrationsFolder)).forEach((file) => {
            files.push(Migrations.resolvePath(Migrations.migrationsFolder, file));
        });
        return files.map((file) => JSON.parse(fs.readFileSync(file, { encoding: "utf8" }).toString()));
    }
    static applyMigrations() {
        return __awaiter(this, void 0, void 0, function* () {
            Migrations.createMigrationsFolder();
            const notApplied = Migrations.readMigrationFiles().filter((x) => !x.applied);
            for (const migration of notApplied) {
                yield DBManager.exec(migration.up, migration.args);
                fs.writeFileSync(Migrations.resolvePath(Migrations.migrationsFolder, migration.filename), JSON.stringify(Object.assign(Object.assign({}, migration), { applied: true })));
            }
        });
    }
    static rollbackToMigration(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = Migrations.readMigrationFiles();
            const migrationIndex = files.findIndex((file) => file.id === id);
            if (migrationIndex === -1) {
                console.log(`No such migration: ${id}`);
                return;
            }
            const rollbackItems = files.slice(migrationIndex);
            for (let i = rollbackItems.length - 1; i >= 0; i--) {
                yield DBManager.exec(rollbackItems[i].down);
                fs.writeFileSync(Migrations.resolvePath(Migrations.migrationsFolder, rollbackItems[i].filename), JSON.stringify(Object.assign(Object.assign({}, rollbackItems[i]), { applied: false })));
            }
        });
    }
    static createMigration({ up, down }) {
        return __awaiter(this, void 0, void 0, function* () {
            yield Migrations.runNewMigration(() => __awaiter(this, void 0, void 0, function* () {
                new Query(up);
                new Query(down);
                yield DBManager.exec(up);
                return { up, down };
            }));
        });
    }
    static bashMigrationInput() {
        return __awaiter(this, void 0, void 0, function* () {
            const up = prompt("Enter New SQL Statement: ");
            const down = prompt("Enter The opposite SQL Action: ");
            if (!up || !down) {
                console.log("please provide up and  down properties!");
                process.exit(1);
            }
            yield Migrations.runNewMigration(() => __awaiter(this, void 0, void 0, function* () {
                new Query(up);
                new Query(down);
                yield DBManager.exec(up);
                return { up, down };
            }));
            console.log("completed!!");
            const continueMig = prompt("Press 1 to continue");
            if (continueMig.trim() !== "1") {
                console.log("BYE!");
                process.exit(0);
            }
            yield Migrations.bashMigrationInput();
        });
    }
}
Migrations.migrationsFolder = "migrations";
module.exports = Migrations;
