class QueryBuilder {
    constructor(schema = "") {
        this.query = "";
        this.queryConfig = [];
        this.schema = "";
        this.schemaStr = "";
        this.argsIndex = 1;
        this.qArgs = [];
        this.bindingOperatorToSQL = { and: "and", or: "or" };
        if (schema) {
            this.schema = `${schema}`;
            this.schemaStr = `${schema}.`;
        }
    }
    select(columns = []) {
        const from = this.queryConfig.find((x) => x.type === "from");
        let alias = "";
        if (from) {
            alias = `${from.alias || from.table}.`;
        }
        const config = {
            priority: 0,
            parts: [],
            type: "select",
        };
        config.parts.push("select");
        if (!(columns === null || columns === void 0 ? void 0 : columns.length)) {
            config.parts.push(`${alias}*`);
        }
        else {
            config.parts = config.parts.concat(columns.map((x) => this.resolveColumnName(x, alias)));
        }
        config.sql = `${config.parts[0]} ${config.parts.slice(1).join(",")}`;
        this.queryConfig.push(config);
        return this;
    }
    from(table, alias) {
        const config = {
            table,
            alias,
            type: "from",
            parts: [`from ${this.schemaStr}${table}`],
            priority: 1,
            sql: `from ${this.schemaStr}${table}`,
        };
        this.queryConfig.push(config);
        return this;
    }
    where(...args) {
        const config = {
            type: "where",
            args,
            parts: ["where"],
            sql: "where",
        };
        const resolved = args.map((x) => this.resolveOperator(x, x === null || x === void 0 ? void 0 : x.type));
        config.parts.push(...resolved);
        config.sql =
            config.sql +
                " " +
                [resolved[0], resolved.slice(1).join(" and ")]
                    .filter(Boolean)
                    .join(" and ");
        this.queryConfig.push(config);
        return this;
    }
    column(name, alias) {
        return {
            sql: `${alias ? `${alias}.` : ""}${name}`,
            args: null,
            $$$isColumn: true,
        };
    }
    eq(...args) {
        return {
            sql: args.map((x) => this.resolveOperator(x)).join(" = "),
            resolved: true,
        };
    }
    neq(...args) {
        return {
            sql: args.map((x) => this.resolveOperator(x)).join(" <> "),
            resolved: true,
        };
    }
    gt(...args) {
        return {
            sql: args.map((x) => this.resolveOperator(x)).join(" > "),
            resolved: true,
        };
    }
    gte(...args) {
        return {
            sql: args.map((x) => this.resolveOperator(x)).join(" >= "),
            resolved: true,
        };
    }
    lt(...args) {
        return {
            sql: args.map((x) => this.resolveOperator(x)).join(" < "),
            resolved: true,
        };
    }
    lte(...args) {
        return {
            sql: args.map((x) => this.resolveOperator(x)).join(" <= "),
            resolved: true,
        };
    }
    and(...args) {
        const clause = Array.isArray(args) ? args : [args];
        const config = {
            type: "and",
            sql: clause.map((x) => this.resolveOperator(x, "and")).join(" and "),
            args: Array.isArray(args) ? args : [args],
        };
        return config;
    }
    or(...args) {
        const clause = Array.isArray(args) ? args : [args];
        const config = {
            type: "or",
            sql: clause.map((x) => this.resolveOperator(x, "or")).join(" or "),
            args: clause,
        };
        return config;
    }
    resolveOperator(input, funcName) {
        if (input.resolved) {
            return input.sql;
        }
        if (!!this.bindingOperatorToSQL[funcName]) {
            const sql = input.args
                .map((x) => this.resolveOperator(x, x === null || x === void 0 ? void 0 : x.type))
                .join(` ${funcName} `);
            return `(${sql})`;
        }
        if (input === null || input === void 0 ? void 0 : input.$$$isColumn) {
            return input.sql;
        }
        else {
            this.qArgs.push(input);
            return `$${this.argsIndex++}`;
        }
    }
    isBindingOperator(func) {
        return ["and", "or"].indexOf(func.name) !== -1;
    }
    update(tableName) {
        const config = {
            type: "update",
            parts: ["update", `${this.schemaStr}${tableName}`],
            sql: `update ${this.schemaStr}${tableName}`,
        };
        this.queryConfig.push(config);
        return this;
    }
    set(...args) {
        const config = {
            type: "set",
            parts: ["set"],
            sql: "",
        };
        this.queryConfig.push(config);
        return this;
    }
    resolveColumnName(x, alias) {
        if (typeof x === "string") {
            return `${alias || ""}${x}`;
        }
        if (x === null || x === void 0 ? void 0 : x.as) {
            return `${alias || ""}${x.name} as ${x.as}`;
        }
        return `${alias || ""}${x.name}`;
    }
}
const qb = new QueryBuilder();
console.time("start");
const y = qb
    .select()
    .from("users")
    .where(qb.eq(qb.column("id", "users"), 2), qb.and(qb.eq(qb.column("id", "users"), 2), qb.eq(qb.column("id", "users"), 2), qb.and(qb.eq(qb.column("id", "users"), qb.eq(qb.column("id", "users"))))))
    .exec();
console.timeEnd("start");
console.log(y);
